\documentclass[a4paper,10pt]{article}


% Title Page
\title{Network Programming\\
\small{Assignment 3: Client-Server programming}}
\author{%
        \mbox{}\\
        Thomas Veerman\\
        \texttt{tveerman@cs.vu.nl}\\
        1329545\\
        \mbox{}\\
        Martijn Vermaat\\
        \texttt{mvermaat@cs.vu.nl}\\
        1362917
}


\begin{document}
\maketitle

\section{A Paper Storage Server}
\paragraph{Question 1}
It is possible to send any number of paper detail structures by using a list:

\begin{tabbing}
\hspace{20pt}\=\kill
 \>\texttt{typedef document document\_list<>;}
\end{tabbing}

However, by omitting the size of the array Sun RPC actually reads that as $2^{32} - 1$, so in fact it is limited. We have chosen to make a linked list:

\begin{tabbing}
\hspace{20pt}\=\kill
 \> \texttt{type}\=\texttt{def} \texttt{struct document\_node *document\_list;}\\ 
 \> \texttt{struct document\_node }\{ \+ \\
 \> \texttt{document item;}\\ 
 \> \texttt{document\_list next;} \- \\
 \> \} 
\end{tabbing}

\paragraph{Question 2}
Normally you define a variable with a fixed size, but than can prove to be troublesome when you have to deal with variable sized data. That is, you will have to cut data up in several chunks when its size is larger than your fixed size variable. This is difficult to get right with Sun RPC. Our solution to this problem was to define an array where we omitted the size, thus defining it as an array of $2^{32} - 1$ bytes (or just under 4 GiB).

\begin{tabbing}
\hspace{20pt}\=\kill
 \>\texttt{typedef opaque data <>;}
\end{tabbing}

This seems to be large enough for transmitting papers.


\section{A Hotel Reservation Server}
\paragraph{Question 3}
Ik weet niet zo goed wat ik hier moet antwoorden. De parameters die we hebben worden of direct overgestuurd (int), of eerst geserialized en dan overgestuurd (String). De Strings zijn dus referenties, maar dat kan nou eenmaal niet anders. Maar, ze worden altijd by value overgestuurd. De Sets die we terugsturen zijn ook referenties, maar worden ook geserialized.

Wat wil hij nou van ons horen?

\section{Hotel Reservation Gateway}
\paragraph{Question 4}
We have used one thread per child as server structure. Though it is unlikely that we will be sending big quantities of data, it can occur that a client is on a very bad connection with high latency and low throughput, which will slow down the server. Also, as we found out first hand, clients that do not follow the protocol may keep the connection open so that other clients cannot connect. By spawning a thread for each incoming connection, this will not be a problem anymore. Of course the server (not the gateway) must support concurrent connections. To be able to do that we made the booking method synchronized, since that is the only method that might cause problems when multiple clients want to book the last room (of a specific type). The other methods only read data, which will never be a problem.

\paragraph{Question 5}
To design a protocol that is suitable for multiple platforms and languages, you need to make sure to keep the differences between platforms and languages in mind. For example, where one platform considers an int as a 16-bit value, others consider it a 32-bit value. In your protocol you have to standardize these differences.

Our solution is to make a plaintext protocol with ascii character encoding, based on HTTP. This is easy to debug, and virtually every platform knows how to interpret ascii character encoding. Almost all data are strings, except for the price of a room, which is a float. We used the standard ascii encoding for a float with precision two (that is, a number followed by a full stop character followed by a number in the range of 00 to 99). (For a detailed description of our protocol, see the program documentation for the hotel gateway.)

\paragraph{Question 6}
The hotelserver obviously runs at the hotel it is serving for. Also the gateway belongs there, since it only serves as a generic means to connect to the hotelserver. The hotelclient belongs to the client that wants to book a room.

\section{Program documentation}
\subsection{A Paper Storage Server}
For the paper storage server we have written 2 programs:
\begin{center}
% use packages: array
\begin{tabular}{ l | p{9cm} }
paperclient.c & a program that connects to the paper server to store papers and retrieve paper info\\ \hline
paperserver.c & an interative server that accepts papers and provides information about the papers\\
\end{tabular}
\end{center}

In the specification file paperstorage.x are our procedures and data types defined.

\paragraph{paperclient.c}
The program starts by typing ./paperclient followed by a number of parameters. How to use the program is printed by omitting the parameters. When the program starts it parses the parameters and executes the corresponding routine, otherwise it will print an error message.

The add, detail, fetch, and list routines roughly work as follows. A client structure is created, parameters are set, remote procedure is called, and results are printed on standard output.

\paragraph{paperserver.c}
The program starts by typing ./paperserver. When the program starts it waits for incoming connections (not actually part of the paperserver object file), and handles the requests.

The detail and fetch routines of the client are handled by the same procedure on the server. The only difference is whether they use the \emph{sparse} or \emph{detailed} flag.

\paragraph{paperstorage.x}
As mentioned earlier it is possible to use different techniques to transfer variably sized data. Where it is possible to use an array with maximum size, we used a linked list.

When a procedure fails, we wanted to send back information telling why something went wrong. Instead of incorporating every bit of data in a structure, we used the more efficient unions.

\subsection{A Hotel Reservation Server}
For the hotel reservation server we have written 9 classes:
\begin{center}
% use packages: array
\begin{tabular}{ l | p{7.0cm} }
Availability.java & structure holding price and the number of still available rooms for a specific room type\\ \hline
HotelClient.java & client program that connects to the hotel reservation server to book rooms and retrieve information\\ \hline
Hotel.java & interface for the hotel service running at the hotel reservation server\\ \hline
HotelServer.java & the Hotel Reservation Server\\ \hline
NotAvailableException.java & exception that occurs when a wanted room is not available\\ \hline
NotBookedException.java & exception handling an internal error\\ \hline
Room.java & a specific room that hold guest information when it is booked\\ \hline
RoomType.java & structure that holds data about the specific types of rooms\\ \hline
SimpleHotel.java & implementation of the hotel service\\
\end{tabular}
\end{center}

\paragraph{Availability.java}
This class is used in a Set to send information about which types of rooms still have rooms left, and at which price.

\paragraph{HotelClient.java}
The program starts by typing ./hotelclient (which is a shell script wrapper around the actual Java program) followed by a number of parameters. How to use the program is printed by omitting the parameters.

We have designed HotelClient such that it can run on its own, but also that it can be incorporated in a larger software package that needs the book, details, and list functions. For example, to make a graphical wrapper around it.

\paragraph{Hotel.java}
This is the interface for the hotel service running at the hotel reservation server. This interface is needed because it is obligatory to extend the java.rmi.Remote interface.
 
\paragraph{HotelServer.java}
The program starts by typing ./hotelserver (which is a shell script wrapper around the actual Java program). Before starting the server the \texttt{rmiregistry} should already be running. However, it is also possible to start your own registry using the \texttt{java.rmi.registry.LocateRegistry} and \texttt{java.rmi.registry.Registry} classes.

The internal workings are pretty simple. The registry is started, a SimpleHotel (implementation of the Hotel interface) is instantiated and bound in the registry. The registry takes care of the rest. 

\paragraph{NotAvailableException.java}
\paragraph{NotBookedException.java}
\paragraph{Room.java}
\paragraph{RoomType.java}
\paragraph{SimpleHotel.java}

\end{document}
