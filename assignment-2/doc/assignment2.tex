\documentclass[a4paper,10pt]{article}


% Title Page
\title{Network Programming\\
\small{Assignment 2: Distributed Programming with Sockets}}
\author{%
        \mbox{}\\
        Thomas Veerman\\
        \texttt{tveerman@cs.vu.nl}\\
        1329545\\
        \mbox{}\\
        Martijn Vermaat\\
        \texttt{mvermaat@cs.vu.nl}\\
        1362917
}


\begin{document}
\maketitle


\section{A Content-Full Server}
\paragraph{Question 1}
Issue 1: connection counter in shared memory? depends on what you mean by 'count' and
what the connection consists of.
Issue 2: writing to a socket (file descriptor) may write less bytes at a time than
provided. (also for reading)

Yes, concurrent requests will be processed correctly, but accepted iteratively one at a
time. Processing of connections can be done concurrently.

\paragraph{Question 2}
Issue 1: connection counter must be in shared memory (alternative might be pipes).
Issue 2: mutual exclusion for the connection counter.
Issue 3: be carefull where and when to remove semaphores and shared memory. always try
to clean up, but not too soon (e.g. within a child process).

Yes, concurrent requests will be processed correctly, and accepted and processed
concurrently.

\section{A Talk Program}
\paragraph{Question 3}
Iterative, there is no need for something more complicated.

\paragraph{Question 4}
Server and client on the same machine is ok. The problem with >1 server instances on the
same machine is that the first server will bind to the port (and subsequent instances
get an address in use error). There are a number of different approaches to this problem,
depending on the application.

1) The server accepts a port number as argument and users just agree on a port number
   (and have bad luck if another team took the same number).

2) For all or most technical solutions you would need another way to differentiate
   between the chat sessions than the port number. This can be registration system based
   on user names, or identifiers for the chat sessions like chat room names.

   a) Use a 'super server' of which address and port number are known to resolve
      usernames or chatrooms to addresses and port numbers. Servers register themselves
      to the super server so their address and port number is known (first they try to
      bind() untill a working port is found). Clients query the super server to know the
      address and port number of the server they need. (A bit like portmapper.)

      A variant on this scheme would be to route all chat traffic through the super
      server.

   b) All servers are 'smart servers' which can act as a kind of 'super server'. On an
      unsuccessful bind() to the default port, the server tries to bind to another port
      and sends a message to the already running server at the default port just like it
      would in scheme (a) to the super server. Now, clients initially try to connect to
      the default port, but only one client should be accepted in the chat directly.
      Subsequent client requests get a response containing the port number of the chat
      instance they are looking for.

\paragraph{Question 5}
We are thinking about using pthreads.

\section{Program documentation}

Some words here.


\end{document}
